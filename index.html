<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>A Comprehensive Overview of Concepts and Algorithms<br/>Used by Modern Chess Engines</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/night.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section data-markdown>
          <textarea data-template>
            ### A Comprehensive Overview of Concepts and Algorithms<br/>Used by Modern Chess Engines
            <br /><br /><br />
            #### Johannes Weinsheimer
            <br /><br /><br />

            <aside data-markdown class="notes">
              - Auf Deutsch um in der Kürze der Zeit hoffentlich alles etwas genauer zu erklären
            </aside> 
          </textarea>
        </section>
				<section data-markdown>
          <textarea data-template>
            #### A Comprehensive Overview of Concepts and Algorithms<br/>Used by Modern Chess Engines
            - (Modern) Chess Engine?
              - Kein <em>Schachprogramm</em>, sondern dessen <em>Motor</em>

            - Artikel: Querschnitt (die wichtigsten Komponenten)
              - Schwerpunkt: Konzepte & Algorithmen, nicht die konkrete Implementierung

            <aside data-markdown class="notes">
              - Beispiel: App fürs Handy
              - Schach-Engine sagt die Züge vor
              - Schach-Engine = Backend, Schachprogramm = Frontend
                - Austausch via Standardprotokoll UCI
            </aside> 
          </textarea>                 
        </section>                      
        <section data-markdown>
          <textarea data-template>
            #### Beispiel für den Einsatz einer Schach-Engine (lichess.org)
            <img src="newscreens/chess_engine.png" />

            <aside data-markdown class="notes">
              - Analysebrett auf lichess.org: Stellung aufbauen und den Computer befragen
              - Schachprogramm ist eine Webanwendung
              - Schach-Engine läuft im Hintergrund, im Browser
              - Thema der Präsentation: Wie kann der Computer da eine sehr sehr qualizierte Aussagen drüber Treffen?
              - Zeit reicht leider nur um die absolute Grundlage davon zu umreissen
            </aside>     
         </textarea>                  
        </section> 
        <section data-markdown>
          <textarea data-template>
            #### Spielbaum
            - Knoten: Positionen

              - Wurzel: Ausgangsposition         
            - Kanten: Züge
            - <u>Tiefe</u> (d): Anzahl der Ebenen (3)
            - <u>Durchschnittlicher Verzweigungsfaktor</u> (b):<br />durchschnittliche Anzahl von Kindern (3)
            
            <img style="float: right;" width="900" src="screens/game_tree.png" />
            <br/>
            <aside data-markdown class="notes">
              - Erster Schritt: Realisieren dass man Schach als Spielbaum darstellen kann
                - möglich auf Grund der spieletheoretischen Eigenschaften
              - Grafik: Beispiel für einen (offensichtlich unvollständigen) Spielbaum              
              - Als Nächstes: Nachdem wir eine Idee haben was ein Spielbaum ist können wir mal folgendes Szenario andenken
            </aside>                     
          </textarea>                       
        </section>         
        <section data-markdown>
          <textarea data-template>
            #### Spielbaum
            - Theorie: Vollständiger Spielbaum

              - Wurzel: Startposition
              - Struktur: immer alle möglichen Züge berücksichtigen

              - Blätter: Positionen mit denen die Partie endet (z.b. Schachmatt)
              - Spielbaum bildet alle möglichen Spielverläufe ab
              - Vorgehen
                - Aktuelle Position suchen
                - <em>Irgendwie</em> den zu erwartenden Spielverlauf vohersagen
                - Resultat: Zug & Ergebnis
          </textarea>                       
        </section>
        <section>
          <section data-markdown>
            <textarea data-template>
              #### Spielbaum          
              - Praxis: Partielle Spielbäume
                - Grund? Exponentielles Wachstum!

                - Anzahl möglicher Positionen nach zwei Zügen: `$ {b^{d}} = {20^{2}} = 400$`
                - Analyse: Tiefe d = 70, durschnittlicher Verzweigungsfaktor b = 30 ergibt ~ `$ {30^{70}} = ...$` Blätter
                - Schlussfolgerung: Tiefe ist limitiert (5-6)
              
              <aside data-markdown class="notes">
                - "Ist Schach lösbar?"
                  - Fehlt an Kapazitäten
                  - Schwer vorstellbar dass sich das jemals ändert
                  - Endspieldatenbanken als "Teillösungen"
                  - Plugin für chess engines das genutzt werden kann wenn nur noch eine bestimmte Mengen bestimmter Figuren auf dem Brett ist
                    - Kombinationen aus 2x König und 5x anderen Figuren -> 14 TB
                    - Auf dem Schachbrett leider 32 Figuren
              </aside>               
            </textarea>                                
          </section>
          <section data-markdown>
            <textarea data-template>
              #### Blätter
              | d  | b = 30 |
              |---|---|
              | 0 | 1 |
              | 1 | 30 |
              | 2 | 900 |
              | 3 | 27.000 |
              | 4 | 810.000 |
              | 5 | 24.300.000 |
              | 6 | <del>729.000.000</del> |
              | 10 | <del>590.490.000.000.000</del> | 
              <aside data-markdown class="notes">
                - Stockfish 14 auf dem PC: 7.5 Millionen Knoten/s
                - Suchtiefe von 5 bis 6 bringt uns nicht weit
              </aside>               
            </textarea>                       
        </section>
        </section>        
        <section> <!-- & Bewertung -->
          <section data-markdown>
            <textarea data-template>
              #### Suche: Suchbaum
              - Erster Schritt für die Vorhersage: Spielbaum -> Suchbaum
              - Wurzel: aktuelle Position
              - Knoten: nicht mehr Positionen im Vordergrund, sondern Zahlwerte
              - Blätter
                - Grundlage für die Vorhersage
                - Bei komplettem Suchbaum: 1 (Sieg: Weiß), 0 (Unentschieden), -1 (Sieg: Schwarz)
                - Aber: meist keine finale Position (Suchbaum ist <em>mittendrin</em>)
        
              <br /><br />
              <img width="500" src="screens/minimax_0.png" />

              <aside data-markdown class="notes">
                - Das "irgendwie den Spielverlauf vorhesagen" noch nicht beantwortet, aber wir gehen immernoch davon aus dass es möglich ist
                - Das hier ist der nächste Schritt
                - Beispiel für "meinst keine Finale position": lichess.org screenshot
                - Extrem vereinfachtes Beispiel!!!!!: wir erinnern uns: durchschnittliche Verzweigugnsfaktor 30, nicht 2, suche Tiefer als 2
                - wenn wir nicht das Ergebnis kennen brauchen wir zumindest eine Orientierung was gut für uns ist
                - Wenn doch finale Position: extreme Werte                
              </aside>                   
            </textarea>                       
          </section> 
          <section data-markdown>
            <textarea data-template>
            #### Evaluation
            - Ergebnis einer <u>statischen</u> Analyse verschiedenster Eigenschaften einer Position

              - vorhandenes Material (= Figuren)
              - restliche Eigenschaften
                - Platzierung der Figuren, Königssicherheit, ...
            - Berechnung (vereinfacht)
              - Für jede Seite: Eigenschaften gewichten & summieren
              - Evaluation = Differenz der Summen              
                - Vorzeichen: für welche Seite ist die Position besser?
                - Betrag: wie groß ist der Vorteil?
            </textarea>          
          </section>   
          <section data-markdown>
            <textarea data-template>
              #### Evaluation: Eigenschaften             
              <img height="700" src="screens/eval_properties_sf_pos_2.png" />
              <img height="700" src="screens/eval_properties_sf_2.png" /> 
              &nbsp;

              via: https://hxim.github.io/Stockfish-Evaluation-Guide/   
              
              <aside data-markdown class="notes">
                - Vielzahl von Eigenschaften
                  - Psqt bonus: gerade angesprochene Platzierung (Weiß)
                  - Connected: Bauern sind miteinander verbunden (Schwarz)      
                  - usw. 
              </aside>                 
            </textarea>                       
          </section>                                 
        </section>
        <section data-markdown>
          <textarea data-template>
            #### Suche: Minimax-Algorithmus
            - Minimax liefert optimale Spielstrategie für Spiele wie Schach

              - Sichert <u>höchstmöglichen</u> Gewinn zu, <u>unabhängig</u> von der <u>Spielweise</u> des Gegners
            - Beide Spieler wollen das für <u>sich</u> bestmögliche Ergebnis erreichen
              - Weiß: maximierende Spieler
              - Schwarz: minimierende Spieler
            &nbsp;
            <br />
            <aside data-markdown class="notes">
              - Antwort auf das "irgendwie den Spielvarlauf vorhersagen" von vorhin
            </aside>                  
          </textarea>                       
        </section>        
        <section data-markdown>
          <textarea data-template>
            #### Suche: Minimax-Algorithmus (Ablauf)
            <img height="250" src="screens/minimax_1.png" />
            <img height="250" src="screens/minimax_2.png" />
            <img height="250" src="screens/minimax_3.png" />
            <img height="250" src="screens/minimax_4.png" />
            <br />
            &nbsp;
            <br /><br /><br />
            
            #### Anmerkungen
            - Weiß spielt Zug der <u>nicht</u> zu der Position mit Bewertung von 8 führen kann

            - Grundannahme: Schwarz spielt immer den bestmöglichen Zug

            - Wurzel: Garantierte Bewertung (bei Abweichungen vom Schwarz: +/=)

            <aside data-markdown class="notes">
              - Minimax Grundlage für alles weitere
              - Ablesen was wir wissen wollten: besten Zug, Bewertung
            </aside>            
          </textarea>                       
        </section>
        <section data-markdown>
          <textarea data-template>
            #### Suche: Minimax-Algorithmus + X (d = 30)    
            <img height="600px" src="newscreens/chess_engine.png" />
            <img height="600px" src="screens/30_gezogen.png" />
  
            <aside data-markdown class="notes">
              - Der Wert in der Wurzel des Suchbaums: Bewertung der nach oben durchgereichten Position
              - Der vorgeschlagene Zug schlägt den Spielverlauf zu dieser Position ein
              - Best case für Schwarz (jede Abweichung vom Pfad führt zu einer besseren Position für Weiß)
            </aside>                  
          </textarea>                         
        </section> 
        <section data-markdown>
          <textarea data-template>
            <br /><br /><br /><br />
            &nbsp;
            ## Vielen Dank für Ihre Aufmerksamkeit!
          </textarea>                       
        </section>                
        <section> <!-- Minimax Fazit & Tabelle -->
          <section data-markdown>
            <textarea data-template>
              #### Suche: Minimax-Algorithmus (Fazit)
              - Vorteil: funktioniert & sehr leicht verständlich

              - Problem: exponentielles Wachstum
              - Suchtiefe die Minimax ermöglicht nicht ausreichend
              - Tiefere Suche & konstante Rechenleistung => weniger Knoten

              <br /><br />

              ### Alpha-Beta Suche

              <aside data-markdown class="notes">
                <em>nach Suchtiefe kurz runterscrollen</em>
              </aside>             
            </textarea>    
          </section>         
        </section>   


      <section data-markdown>
        <textarea data-template>
          #### Suche: Alpha-Beta Algorithmus (Alpha-Beta search / pruning)
          - Die wichtigste Verbesserung von Minimax

          - Ermöglicht das Trimmen (pruning) des Suchbaums
          - Idee: Zweige abschneiden die nicht von Interesse sind

        </textarea>                       
      </section>
      <section>
        <section data-markdown>
          <textarea data-template>
            #### Suche: Alpha-Beta Algorithmus
            <div class="r-stack">
              <img class="fragment" height="600" src="screens/alpha_beta_original_1.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_2.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_3.png" /> 
              <img class="fragment" height="600" src="screens/alpha_beta_original_4.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_5.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_6.png" /> 
              <img class="fragment" height="600" src="screens/alpha_beta_original_7.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_8.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_9.png" /> 
              <img class="fragment" height="600" src="screens/alpha_beta_original_10.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_11.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_12.png" /> 
              <img class="fragment" height="600" src="screens/alpha_beta_original_13.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_14png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_15.png" /> 
              <img class="fragment" height="600" src="screens/alpha_beta_original_16.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_17.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_18.png" /> 
              <img class="fragment" height="600" src="screens/alpha_beta_original_19.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_20.png" />
              <img class="fragment" height="600" src="screens/alpha_beta_original_21.png" />                                                                                                                
            </div>            
          </textarea>                               
        </section>          
        <section data-markdown>
          <textarea data-template>
            #### Suche: Alpha-Beta Algorithmus
            <img height="400" src="screens/alpha_beta_1.png" />
            <br />
            &nbsp;
            <br />
            
            #### Hinweise
            - Ausgangszustand: Nur Werte in den Blättern
            - Grauer Hintergrund: Knoten werden nicht erreicht
            - Rote Striche: Schnitte (Cut-offs)
            - Generieren von Zügen sowie Evaluieren von Positionen passiert <i>on demand</i>  
          </textarea>                               
        </section>   
        <section data-markdown>
          <textarea data-template>
            #### Suche: Alpha-Beta Algorithmus
            <img height="400" src="screens/alpha_beta_2.png" />
            <br />
            &nbsp;
            <br />
            
            #### Beschreibung
            - Alpha: Ergebnis das der maximierende Spieler mindestens erreichen wird
            - Beta: Ergebnis das der minimierende Spieler höchstens erreichen wird
              - im Sinne von: möglichst niedriger Wert
            - Initialisierung mit -INF (Alpha) bzw. +INF (Beta)


            <aside data-markdown class="notes">
              - Tiefensuchen, also direkt den jeweils linken Zweig wählen und unten links anfangen
            </aside>                 
          </textarea>                       
        </section> 
      </section>        
      <section data-markdown>
        <textarea data-template>
          #### Suche: Alpha-Beta Algorithmus
          <img height="400" src="screens/alpha_beta_mo.png" />
          <br />
          &nbsp;
          <br />

          - Andere Zugreihenfolge an zwei Stellen verhindert beide Cut-offs
        </textarea>                       
      </section>  
      <section data-markdown>
        <textarea data-template>
          #### Suche: Alpha-Beta vs. Minimax
          - Reihenfolge von Zügen von essentieller Bedeutung

          - Worst case
            - Anzahl der Blätter: `$ O({b^{d}}) $`
          - Best case
            - Anzahl der Blätter: `$ O({b^{d/2}}) $` = `$ O(\sqrt{b^{d}}) $`
            - Interpretation: <u>doppelte</u> Suchtiefe bei konstanten Bedingungen
          - Glück erzwingen: Züge werden "sortiert" (move ordering)
        </textarea>                       
      </section>
      <section>
        <section data-markdown>
          <textarea data-template>
            #### Suche: Alpha-Beta Algorithmus (minimaler Suchbaum)
            <img height="400" src="screens/alpha_beta_minimal_alt.png" />
            <br />
            &nbsp;
            <br />

            - Sortierung der Züge: vom Besten zum Schlechsten (je nach Perspektive)

            - für d = 3 und b = 3 nur 11 statt 27 Blätter!
            - Anzahl der Blätter: `$ O({b^{d/2}}) $` = `$ O(b \cdot 1 \cdot b \cdot 1 \cdot b \cdot ...)$`
          </textarea>                       
        </section>
        <section data-markdown>
          <textarea data-template>
            #### Alpha-Beta vs. Minimax: Blätter (b = 30)
            | d  | Minimax  | Alpha-Beta (optimal) |
            |---|---|---|
            | 0 | 1 | 1 |
            | 1 | 30 | 30 |
            | 2 | 900 | 59 |
            | 3 | 27.000 | 929 |
            | 4 | 810.000 | 1.799 |
            | 5 | 24.300.000 | 27.899 |
            | 10 | 590.490.000.000.000 | 48.599.999 |  
            
            &nbsp;
            #### Beobachtung
            - Bei Alpha-Beta (optimal): exponentielles Wachstum bei jeder zweiten (geraden) Tiefe,<br />
            sonst: Faktor ~2
          </textarea>                       
        </section>
      </section>        
      <section data-markdown>
        <textarea data-template>
          #### Suche: Iterative Tiefensuche (iterative deepening)
          - Frage: Wieviel Zeit steht zur Verfügung den besten Zug zu finden?

          - Problem: Was passiert wenn die Suche abgebrochen wird?
          - Lösung: Iterative Tiefensuche
          - Idee: Suchdurchläufe mit immer höherer Suchtiefe (Start bei d = 0)
          - Ab gewisser Tiefe jederzeit starker Zug verfügbar

          <img height="400" src="screens/alpha_beta_id.png" />
          
        </textarea>                       
      </section>
      <section data-markdown>
        <textarea data-template>
          #### Suche: Iterative Tiefensuche
          - Frage: Ist das nicht sehr aufwändig? Nein!
          - Faktoren
            - Mechanismus um jederzeit einen sehr starken Zug zu liefern
            - Mehraufwand geringer als vermutet
              - Annahme: `$b = 10$`
              - Letzte Suche: `$ {b^{d}} $` Blätter
              - Vorletzte Suche: `$ {b^{d-1}} $` Blätter
              - Vorvorletzte Suche: `$ {b^{d-2}} $` Blätter
              - Unterschied: Faktor von `$10$` `$(= b)$`
              - Aufwand: vorletzte Suche ~10% der letzten Suche, vorvorletzte Suche ~1% der letzten Suche
              - Insgesamt ~10% mehr Aufwand nötig
            - UND: Resultat der vorherigen Suchen für Sortierung der Züge des nächsten Suchdurchlaufs nutzbar
          - Suche wird durch Anwendung der iterativen Tiefensuche <u>besser</u>!
        </textarea>                       
      </section>       
      <section data-markdown>
        <textarea data-template>
          #### Ruhesuche (quiescence search)
          - Generell ungünstig bei einer fixen Suchtiefe abzubrechen, je nach letztem Zug
          - von Interesse: Schlagen von Figuren und Schachgebote
            - erhöhte Chance auf Veränderung der Bewertung unterhalb des Suchhorizonts
          - generelles Problem: horizon effect
          - Ruhesuche als bester Lösungsansatz: Selektive Erweiterung des Suchbaums

          <img height="350" src="screens/quiescent_search.png" />

          #### Wichtig
          - Suchexplosion (search explosion) vermeiden
        </textarea>                       
      </section> 
      <section data-markdown>
        <textarea data-template>
          #### Ruhesuche: Beispiel (die zwei letzten Positionen eines Astes)
          <img height="400" src="screens/evaluation_4.png" />
          <img height="400" src="screens/quiescene_search_example.png" />

          ### 
          - Der Abtausch von Figuren auf dem Feld C6 wird weiter untersucht
            - Dame kann geschlagen werden, Springer danach nicht
            - Minimaler Aufwand hat Bewertung signikfant korrigiert
        </textarea>                       
      </section>
      <section>
        <section data-markdown>
          <textarea data-template>
            #### Wie geht es weiter?
            - Selbst bei optimaler Zugreihenfolge: Suchtiefe von ~10
            - Weitere Verbesserung der Suche notwendig
              - Modifizierung der Alpha-Beta Suche für mehr Cut-offs
                - <u>Verhältnis</u> von Aufwand und Vorteil wichtig
              - Suchbaum erweitern wo der Aufwand gering ist (keine Suchexplosion)
              - Suchbaum reduzieren wo keine gute Position erwartet wird
                - Gefahr: Möglichkeiten können <u>übersehen</u> werden
            - Wie weit können Schach-Engines den effektiven Verzweigungsfaktor reduzieren?
          </textarea>                       
        </section>
        <section data-markdown>
          <textarea data-template>
            # 1.5!
            &nbsp;
            #### Blätter (b = 30)
            | d  | Minimax  | Alpha-Beta (optimal) | Final (b = 2) |
            |---|---|---|---|
            | 5 | 24.300.000 | 27.899 | 32 |
            | 10 | ... | 48.599.999 | 1.024 |
            | 15 | ... | ... | 32.768 |
            | 20 | ... | ... | 1.048.576 |
            | 25 | ... | ... | 33.554.432 |
          </textarea>                       
        </section>
      </section>            
      <section data-markdown>
        <textarea data-template>
          <br /><br /><br /><br />
          &nbsp;
          ## Vielen Dank für Ihre Aufmerksamkeit!
        </textarea>                       
      </section>                                                            
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

        width: 1920,
        height: 800,

        center: false,
        slideNumber: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>
